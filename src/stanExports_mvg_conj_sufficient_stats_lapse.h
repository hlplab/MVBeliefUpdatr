// Generated by rstantools.  Do not edit by hand.

/*
    MVbeliefupdatr is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    MVbeliefupdatr is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with MVbeliefupdatr.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#ifndef USE_STANC3
#define USE_STANC3
#endif
#include <rstan/rstaninc.hpp>
// Code generated by stanc v2.26.1-4-gd72b68b7-dirty
#include <stan/model/model_header.hpp>
namespace model_mvg_conj_sufficient_stats_lapse_namespace {
inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}
inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}
using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 
stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 53, column 4 to column 26)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 54, column 4 to column 27)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 55, column 4 to column 70)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 56, column 4 to column 43)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 57, column 4 to column 47)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 58, column 4 to column 56)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 59, column 4 to column 54)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 60, column 4 to column 63)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 63, column 2 to column 18)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 64, column 2 to column 19)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 65, column 2 to column 23)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 67, column 2 to column 29)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 68, column 2 to column 26)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 69, column 2 to column 21)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 70, column 2 to column 25)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 71, column 2 to column 29)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 72, column 2 to column 33)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 73, column 2 to column 36)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 77, column 4 to column 37)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 76, column 9 to line 78, column 3)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 75, column 4 to column 36)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 74, column 24 to line 76, column 3)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 74, column 2 to line 78, column 3)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 82, column 4 to column 20)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 81, column 9 to line 83, column 3)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 80, column 4 to column 19)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 79, column 17 to line 81, column 3)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 79, column 2 to line 83, column 3)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 85, column 4 to column 19)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 84, column 17 to line 86, column 3)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 84, column 2 to line 86, column 3)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 92, column 6 to column 107)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 90, column 20 to line 93, column 5)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 90, column 4 to line 93, column 5)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 105, column 8 to column 37)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 106, column 8 to column 31)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 107, column 8 to column 34)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 108, column 8 to column 34)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 104, column 13 to line 109, column 7)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 96, column 8 to column 52)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 97, column 8 to column 46)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 98, column 8 to line 99, column 29)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 100, column 8 to line 103, column 78)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 95, column 29 to line 104, column 7)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 95, column 6 to line 109, column 7)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 110, column 6 to line 111, column 57)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 94, column 23 to line 112, column 5)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 94, column 4 to line 112, column 5)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 89, column 19 to line 113, column 3)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 89, column 2 to line 113, column 3)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 116, column 4 to column 14)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 117, column 4 to column 22)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 120, column 6 to line 123, column 72)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 119, column 21 to line 124, column 5)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 119, column 4 to line 124, column 5)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 126, column 4 to column 79)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 115, column 22 to line 127, column 3)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 115, column 2 to line 127, column 3)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 159, column 11 to column 12)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 159, column 13 to column 14)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 159, column 4 to column 24)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 160, column 11 to column 12)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 160, column 13 to column 14)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 160, column 4 to column 24)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 161, column 4 to column 61)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 162, column 4 to column 47)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 158, column 18 to line 163, column 3)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 158, column 2 to line 163, column 3)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 130, column 9 to column 10)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 130, column 2 to column 26)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 133, column 2 to column 48)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 134, column 2 to column 37)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 135, column 2 to column 34)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 142, column 6 to column 57)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 143, column 6 to column 77)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 144, column 6 to column 99)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 141, column 20 to line 145, column 5)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 141, column 4 to line 145, column 5)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 149, column 8 to column 69)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 150, column 8 to column 88)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 148, column 23 to line 151, column 7)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 148, column 6 to line 151, column 7)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 147, column 20 to line 152, column 5)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 147, column 4 to line 152, column 5)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 154, column 4 to column 84)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 153, column 22 to line 155, column 3)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 153, column 2 to line 155, column 3)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 17, column 4 to column 10)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 18, column 4 to column 10)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 19, column 4 to column 10)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 24, column 11 to column 12)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 24, column 13 to column 14)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 24, column 4 to column 18)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 25, column 21 to column 22)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 25, column 23 to column 24)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 25, column 11 to column 12)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 25, column 4 to column 26)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 26, column 23 to column 24)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 26, column 25 to column 26)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 26, column 15 to column 16)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 26, column 4 to column 28)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 27, column 4 to column 15)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 28, column 21 to column 27)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 28, column 11 to column 12)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 28, column 4 to column 29)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 29, column 15 to column 21)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 29, column 4 to column 23)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 30, column 22 to column 28)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 30, column 29 to column 30)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 30, column 4 to column 32)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 31, column 4 to column 43)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 32, column 4 to column 36)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 33, column 4 to column 36)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 34, column 25 to column 49)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 34, column 4 to column 51)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 35, column 39 to column 56)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 35, column 11 to column 28)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 35, column 4 to column 58)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 36, column 43 to column 60)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 36, column 15 to column 32)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 36, column 4 to column 62)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 42, column 4 to column 28)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 43, column 4 to column 32)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 46, column 2 to column 21)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 49, column 4 to column 49)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 55, column 44 to column 68)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 56, column 24 to column 41)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 56, column 11 to column 12)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 57, column 20 to column 37)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 58, column 25 to column 42)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 59, column 35 to column 52)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 59, column 20 to column 21)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 60, column 44 to column 61)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 60, column 25 to column 26)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 64, column 16 to column 17)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 64, column 9 to column 10)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 65, column 20 to column 21)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 65, column 13 to column 14)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 67, column 24 to column 25)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 67, column 26 to column 27)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 68, column 21 to column 22)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 68, column 23 to column 24)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 69, column 16 to column 17)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 69, column 18 to column 19)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 69, column 9 to column 10)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 70, column 20 to column 21)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 70, column 22 to column 23)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 70, column 13 to column 14)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 71, column 24 to column 25)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 71, column 26 to column 27)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 71, column 13 to column 14)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 72, column 25 to column 31)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 72, column 10 to column 11)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 73, column 28 to column 34)",
                                                      " (in 'mvg_conj_sufficient_stats_lapse', line 73, column 9 to column 10)"};
#include <stan_meta_header.hpp>
class model_mvg_conj_sufficient_stats_lapse final : public model_base_crtp<model_mvg_conj_sufficient_stats_lapse> {
private:
  int M;
  int L;
  int K;
  Eigen::Matrix<double, -1, -1> N;
  std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> x_mean;
  std::vector<std::vector<Eigen::Matrix<double, -1, -1>>> x_ss;
  int N_test;
  std::vector<Eigen::Matrix<double, -1, 1>> x_test;
  std::vector<int> y_test;
  std::vector<std::vector<int>> z_test_counts;
  int lapse_rate_known;
  int m_0_known;
  int S_0_known;
  std::vector<double> lapse_rate_data;
  std::vector<Eigen::Matrix<double, -1, 1>> m_0_data;
  std::vector<Eigen::Matrix<double, -1, -1>> S_0_data;
  double tau_scale;
  double L_omega_scale;
  double sigma_kappanu;
  int lapse_rate_param_1dim__;
  int m_0_param_1dim__;
  int m_0_tau_1dim__;
  int m_0_L_omega_1dim__;
  int m_0_L_omega_2dim__;
  int tau_0_param_1dim__;
  int L_omega_0_param_1dim__;
 
public:
  ~model_mvg_conj_sufficient_stats_lapse() { }
  
  inline std::string model_name() const final { return "model_mvg_conj_sufficient_stats_lapse"; }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 v2.26.1-4-gd72b68b7-dirty", "stancflags = "};
  }
  
  
  model_mvg_conj_sufficient_stats_lapse(stan::io::var_context& context__,
                                        unsigned int random_seed__ = 0,
                                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "model_mvg_conj_sufficient_stats_lapse_namespace::model_mvg_conj_sufficient_stats_lapse";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 88;
      context__.validate_dims("data initialization","M","int",
          context__.to_vec());
      M = std::numeric_limits<int>::min();
      
      current_statement__ = 88;
      M = context__.vals_i("M")[(1 - 1)];
      current_statement__ = 89;
      context__.validate_dims("data initialization","L","int",
          context__.to_vec());
      L = std::numeric_limits<int>::min();
      
      current_statement__ = 89;
      L = context__.vals_i("L")[(1 - 1)];
      current_statement__ = 90;
      context__.validate_dims("data initialization","K","int",
          context__.to_vec());
      K = std::numeric_limits<int>::min();
      
      current_statement__ = 90;
      K = context__.vals_i("K")[(1 - 1)];
      current_statement__ = 91;
      validate_non_negative_index("N", "M", M);
      current_statement__ = 92;
      validate_non_negative_index("N", "L", L);
      current_statement__ = 93;
      context__.validate_dims("data initialization","N","double",
          context__.to_vec(M, L));
      N = Eigen::Matrix<double, -1, -1>(M, L);
      stan::math::fill(N, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> N_flat__;
        current_statement__ = 93;
        assign(N_flat__, nil_index_list(), context__.vals_r("N"),
          "assigning variable N_flat__");
        current_statement__ = 93;
        pos__ = 1;
        current_statement__ = 93;
        for (int sym1__ = 1; sym1__ <= L; ++sym1__) {
          current_statement__ = 93;
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            current_statement__ = 93;
            assign(N,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              N_flat__[(pos__ - 1)], "assigning variable N");
            current_statement__ = 93;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 94;
      validate_non_negative_index("x_mean", "M", M);
      current_statement__ = 95;
      validate_non_negative_index("x_mean", "L", L);
      current_statement__ = 96;
      validate_non_negative_index("x_mean", "K", K);
      current_statement__ = 97;
      context__.validate_dims("data initialization","x_mean","double",
          context__.to_vec(M, L, K));
      x_mean = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(M, std::vector<Eigen::Matrix<double, -1, 1>>(L, Eigen::Matrix<double, -1, 1>(K)));
      stan::math::fill(x_mean, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> x_mean_flat__;
        current_statement__ = 97;
        assign(x_mean_flat__, nil_index_list(), context__.vals_r("x_mean"),
          "assigning variable x_mean_flat__");
        current_statement__ = 97;
        pos__ = 1;
        current_statement__ = 97;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          current_statement__ = 97;
          for (int sym2__ = 1; sym2__ <= L; ++sym2__) {
            current_statement__ = 97;
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              current_statement__ = 97;
              assign(x_mean,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                x_mean_flat__[(pos__ - 1)], "assigning variable x_mean");
              current_statement__ = 97;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 98;
      validate_non_negative_index("x_ss", "M", M);
      current_statement__ = 99;
      validate_non_negative_index("x_ss", "L", L);
      current_statement__ = 100;
      validate_non_negative_index("x_ss", "K", K);
      current_statement__ = 100;
      validate_non_negative_index("x_ss", "K", K);
      current_statement__ = 101;
      context__.validate_dims("data initialization","x_ss","double",
          context__.to_vec(M, L, K, K));
      x_ss = std::vector<std::vector<Eigen::Matrix<double, -1, -1>>>(M, std::vector<Eigen::Matrix<double, -1, -1>>(L, Eigen::Matrix<double, -1, -1>(K, K)));
      stan::math::fill(x_ss, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> x_ss_flat__;
        current_statement__ = 101;
        assign(x_ss_flat__, nil_index_list(), context__.vals_r("x_ss"),
          "assigning variable x_ss_flat__");
        current_statement__ = 101;
        pos__ = 1;
        current_statement__ = 101;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          current_statement__ = 101;
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            current_statement__ = 101;
            for (int sym3__ = 1; sym3__ <= L; ++sym3__) {
              current_statement__ = 101;
              for (int sym4__ = 1; sym4__ <= M; ++sym4__) {
                current_statement__ = 101;
                assign(x_ss,
                  cons_list(index_uni(sym4__),
                    cons_list(index_uni(sym3__),
                      cons_list(index_uni(sym2__),
                        cons_list(index_uni(sym1__), nil_index_list())))),
                  x_ss_flat__[(pos__ - 1)], "assigning variable x_ss");
                current_statement__ = 101;
                pos__ = (pos__ + 1);}}}}
      }
      current_statement__ = 101;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 101;
        for (int sym2__ = 1; sym2__ <= L; ++sym2__) {
          current_statement__ = 101;
          current_statement__ = 101;
          check_cov_matrix(function__, "x_ss[sym1__, sym2__]",
                           x_ss[(sym1__ - 1)][(sym2__ - 1)]);}}
      current_statement__ = 102;
      context__.validate_dims("data initialization","N_test","int",
          context__.to_vec());
      N_test = std::numeric_limits<int>::min();
      
      current_statement__ = 102;
      N_test = context__.vals_i("N_test")[(1 - 1)];
      current_statement__ = 103;
      validate_non_negative_index("x_test", "N_test", N_test);
      current_statement__ = 104;
      validate_non_negative_index("x_test", "K", K);
      current_statement__ = 105;
      context__.validate_dims("data initialization","x_test","double",
          context__.to_vec(N_test, K));
      x_test = std::vector<Eigen::Matrix<double, -1, 1>>(N_test, Eigen::Matrix<double, -1, 1>(K));
      stan::math::fill(x_test, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> x_test_flat__;
        current_statement__ = 105;
        assign(x_test_flat__, nil_index_list(), context__.vals_r("x_test"),
          "assigning variable x_test_flat__");
        current_statement__ = 105;
        pos__ = 1;
        current_statement__ = 105;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          current_statement__ = 105;
          for (int sym2__ = 1; sym2__ <= N_test; ++sym2__) {
            current_statement__ = 105;
            assign(x_test,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              x_test_flat__[(pos__ - 1)], "assigning variable x_test");
            current_statement__ = 105;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 106;
      validate_non_negative_index("y_test", "N_test", N_test);
      current_statement__ = 107;
      context__.validate_dims("data initialization","y_test","int",
          context__.to_vec(N_test));
      y_test = std::vector<int>(N_test, std::numeric_limits<int>::min());
      
      current_statement__ = 107;
      assign(y_test, nil_index_list(), context__.vals_i("y_test"),
        "assigning variable y_test");
      current_statement__ = 108;
      validate_non_negative_index("z_test_counts", "N_test", N_test);
      current_statement__ = 109;
      validate_non_negative_index("z_test_counts", "M", M);
      current_statement__ = 110;
      context__.validate_dims("data initialization","z_test_counts","int",
          context__.to_vec(N_test, M));
      z_test_counts = std::vector<std::vector<int>>(N_test, std::vector<int>(M, std::numeric_limits<int>::min()));
      
      {
        std::vector<int> z_test_counts_flat__;
        current_statement__ = 110;
        assign(z_test_counts_flat__, nil_index_list(),
          context__.vals_i("z_test_counts"),
          "assigning variable z_test_counts_flat__");
        current_statement__ = 110;
        pos__ = 1;
        current_statement__ = 110;
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          current_statement__ = 110;
          for (int sym2__ = 1; sym2__ <= N_test; ++sym2__) {
            current_statement__ = 110;
            assign(z_test_counts,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              z_test_counts_flat__[(pos__ - 1)],
              "assigning variable z_test_counts");
            current_statement__ = 110;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 111;
      context__.validate_dims("data initialization","lapse_rate_known","int",
          context__.to_vec());
      lapse_rate_known = std::numeric_limits<int>::min();
      
      current_statement__ = 111;
      lapse_rate_known = context__.vals_i("lapse_rate_known")[(1 - 1)];
      current_statement__ = 111;
      current_statement__ = 111;
      check_greater_or_equal(function__, "lapse_rate_known",
                             lapse_rate_known, 0);
      current_statement__ = 111;
      current_statement__ = 111;
      check_less_or_equal(function__, "lapse_rate_known", lapse_rate_known, 1);
      current_statement__ = 112;
      context__.validate_dims("data initialization","m_0_known","int",
          context__.to_vec());
      m_0_known = std::numeric_limits<int>::min();
      
      current_statement__ = 112;
      m_0_known = context__.vals_i("m_0_known")[(1 - 1)];
      current_statement__ = 112;
      current_statement__ = 112;
      check_greater_or_equal(function__, "m_0_known", m_0_known, 0);
      current_statement__ = 112;
      current_statement__ = 112;
      check_less_or_equal(function__, "m_0_known", m_0_known, 1);
      current_statement__ = 113;
      context__.validate_dims("data initialization","S_0_known","int",
          context__.to_vec());
      S_0_known = std::numeric_limits<int>::min();
      
      current_statement__ = 113;
      S_0_known = context__.vals_i("S_0_known")[(1 - 1)];
      current_statement__ = 113;
      current_statement__ = 113;
      check_greater_or_equal(function__, "S_0_known", S_0_known, 0);
      current_statement__ = 113;
      current_statement__ = 113;
      check_less_or_equal(function__, "S_0_known", S_0_known, 1);
      current_statement__ = 114;
      validate_non_negative_index("lapse_rate_data",
                                  "lapse_rate_known ? 1 : 0",
                                  (lapse_rate_known ? 1 : 0));
      current_statement__ = 115;
      context__.validate_dims("data initialization","lapse_rate_data",
          "double",context__.to_vec((lapse_rate_known ? 1 : 0)));
      lapse_rate_data = std::vector<double>((lapse_rate_known ? 1 : 0), std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 115;
      assign(lapse_rate_data, nil_index_list(),
        context__.vals_r("lapse_rate_data"),
        "assigning variable lapse_rate_data");
      current_statement__ = 116;
      validate_non_negative_index("m_0_data", "m_0_known ? M : 0",
                                  (m_0_known ? M : 0));
      current_statement__ = 117;
      validate_non_negative_index("m_0_data", "m_0_known ? K : 0",
                                  (m_0_known ? K : 0));
      current_statement__ = 118;
      context__.validate_dims("data initialization","m_0_data","double",
          context__.to_vec((m_0_known ? M : 0), (m_0_known ? K : 0)));
      m_0_data = std::vector<Eigen::Matrix<double, -1, 1>>((m_0_known ? M : 0), Eigen::Matrix<double, -1, 1>((
        m_0_known ? K : 0)));
      stan::math::fill(m_0_data, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> m_0_data_flat__;
        current_statement__ = 118;
        assign(m_0_data_flat__, nil_index_list(),
          context__.vals_r("m_0_data"), "assigning variable m_0_data_flat__");
        current_statement__ = 118;
        pos__ = 1;
        current_statement__ = 118;
        for (int sym1__ = 1; sym1__ <= (m_0_known ? K : 0); ++sym1__) {
          current_statement__ = 118;
          for (int sym2__ = 1; sym2__ <= (m_0_known ? M : 0); ++sym2__) {
            current_statement__ = 118;
            assign(m_0_data,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              m_0_data_flat__[(pos__ - 1)], "assigning variable m_0_data");
            current_statement__ = 118;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 119;
      validate_non_negative_index("S_0_data", "S_0_known ? M : 0",
                                  (S_0_known ? M : 0));
      current_statement__ = 120;
      validate_non_negative_index("S_0_data", "S_0_known ? K : 0",
                                  (S_0_known ? K : 0));
      current_statement__ = 120;
      validate_non_negative_index("S_0_data", "S_0_known ? K : 0",
                                  (S_0_known ? K : 0));
      current_statement__ = 121;
      context__.validate_dims("data initialization","S_0_data","double",
          context__.to_vec((S_0_known ? M : 0), (S_0_known ? K : 0),
            (S_0_known ? K : 0)));
      S_0_data = std::vector<Eigen::Matrix<double, -1, -1>>((S_0_known ? M :
                                                               0), Eigen::Matrix<double, -1, -1>((
        S_0_known ? K : 0), (S_0_known ? K : 0)));
      stan::math::fill(S_0_data, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> S_0_data_flat__;
        current_statement__ = 121;
        assign(S_0_data_flat__, nil_index_list(),
          context__.vals_r("S_0_data"), "assigning variable S_0_data_flat__");
        current_statement__ = 121;
        pos__ = 1;
        current_statement__ = 121;
        for (int sym1__ = 1; sym1__ <= (S_0_known ? K : 0); ++sym1__) {
          current_statement__ = 121;
          for (int sym2__ = 1; sym2__ <= (S_0_known ? K : 0); ++sym2__) {
            current_statement__ = 121;
            for (int sym3__ = 1; sym3__ <= (S_0_known ? M : 0); ++sym3__) {
              current_statement__ = 121;
              assign(S_0_data,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                S_0_data_flat__[(pos__ - 1)], "assigning variable S_0_data");
              current_statement__ = 121;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 121;
      for (int sym1__ = 1; sym1__ <= (S_0_known ? M : 0); ++sym1__) {
        current_statement__ = 121;
        current_statement__ = 121;
        check_cov_matrix(function__, "S_0_data[sym1__]",
                         S_0_data[(sym1__ - 1)]);}
      current_statement__ = 122;
      context__.validate_dims("data initialization","tau_scale","double",
          context__.to_vec());
      tau_scale = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 122;
      tau_scale = context__.vals_r("tau_scale")[(1 - 1)];
      current_statement__ = 122;
      current_statement__ = 122;
      check_greater_or_equal(function__, "tau_scale", tau_scale, 0);
      current_statement__ = 123;
      context__.validate_dims("data initialization","L_omega_scale","double",
          context__.to_vec());
      L_omega_scale = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 123;
      L_omega_scale = context__.vals_r("L_omega_scale")[(1 - 1)];
      current_statement__ = 123;
      current_statement__ = 123;
      check_greater_or_equal(function__, "L_omega_scale", L_omega_scale, 0);
      current_statement__ = 124;
      sigma_kappanu = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 125;
      sigma_kappanu = (logical_gt(max(N), 0) ?
                         stan::math::promote_scalar<double>((max(N) * 4)) :
                         stan::math::promote_scalar<double>(10));
      current_statement__ = 126;
      lapse_rate_param_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 126;
      lapse_rate_param_1dim__ = (lapse_rate_known ? 0 : 1);
      current_statement__ = 126;
      validate_non_negative_index("lapse_rate_param",
                                  "lapse_rate_known ? 0 : 1",
                                  lapse_rate_param_1dim__);
      current_statement__ = 127;
      m_0_param_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 127;
      m_0_param_1dim__ = (m_0_known ? 0 : M);
      current_statement__ = 127;
      validate_non_negative_index("m_0_param", "m_0_known ? 0 : M",
                                  m_0_param_1dim__);
      current_statement__ = 128;
      validate_non_negative_index("m_0_param", "K", K);
      current_statement__ = 129;
      m_0_tau_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 129;
      m_0_tau_1dim__ = (m_0_known ? 0 : K);
      current_statement__ = 129;
      validate_non_negative_index("m_0_tau", "m_0_known ? 0 : K",
                                  m_0_tau_1dim__);
      current_statement__ = 130;
      m_0_L_omega_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 130;
      m_0_L_omega_1dim__ = (m_0_known ? 0 : K);
      current_statement__ = 130;
      validate_non_negative_index("m_0_L_omega", "m_0_known ? 0 : K",
                                  m_0_L_omega_1dim__);
      current_statement__ = 130;
      m_0_L_omega_2dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 130;
      m_0_L_omega_2dim__ = (m_0_known ? 0 : K);
      current_statement__ = 130;
      validate_non_negative_index("m_0_L_omega", "m_0_known ? 0 : K",
                                  m_0_L_omega_2dim__);
      current_statement__ = 131;
      tau_0_param_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 131;
      tau_0_param_1dim__ = (S_0_known ? 0 : M);
      current_statement__ = 131;
      validate_non_negative_index("tau_0_param", "S_0_known ? 0 : M",
                                  tau_0_param_1dim__);
      current_statement__ = 132;
      validate_non_negative_index("tau_0_param", "K", K);
      current_statement__ = 133;
      L_omega_0_param_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 133;
      L_omega_0_param_1dim__ = (S_0_known ? 0 : M);
      current_statement__ = 133;
      validate_non_negative_index("L_omega_0_param", "S_0_known ? 0 : M",
                                  L_omega_0_param_1dim__);
      current_statement__ = 134;
      validate_non_negative_index("L_omega_0_param", "K", K);
      current_statement__ = 134;
      validate_non_negative_index("L_omega_0_param", "K", K);
      current_statement__ = 135;
      validate_non_negative_index("m_0", "M", M);
      current_statement__ = 136;
      validate_non_negative_index("m_0", "K", K);
      current_statement__ = 137;
      validate_non_negative_index("S_0", "M", M);
      current_statement__ = 138;
      validate_non_negative_index("S_0", "K", K);
      current_statement__ = 138;
      validate_non_negative_index("S_0", "K", K);
      current_statement__ = 139;
      validate_non_negative_index("kappa_n", "M", M);
      current_statement__ = 140;
      validate_non_negative_index("kappa_n", "L", L);
      current_statement__ = 141;
      validate_non_negative_index("nu_n", "M", M);
      current_statement__ = 142;
      validate_non_negative_index("nu_n", "L", L);
      current_statement__ = 143;
      validate_non_negative_index("m_n", "M", M);
      current_statement__ = 144;
      validate_non_negative_index("m_n", "L", L);
      current_statement__ = 145;
      validate_non_negative_index("m_n", "K", K);
      current_statement__ = 146;
      validate_non_negative_index("S_n", "M", M);
      current_statement__ = 147;
      validate_non_negative_index("S_n", "L", L);
      current_statement__ = 148;
      validate_non_negative_index("S_n", "K", K);
      current_statement__ = 148;
      validate_non_negative_index("S_n", "K", K);
      current_statement__ = 149;
      validate_non_negative_index("t_scale", "M", M);
      current_statement__ = 150;
      validate_non_negative_index("t_scale", "L", L);
      current_statement__ = 151;
      validate_non_negative_index("t_scale", "K", K);
      current_statement__ = 151;
      validate_non_negative_index("t_scale", "K", K);
      current_statement__ = 152;
      validate_non_negative_index("p_test_conj", "N_test", N_test);
      current_statement__ = 153;
      validate_non_negative_index("p_test_conj", "M", M);
      current_statement__ = 154;
      validate_non_negative_index("log_p_test_conj", "N_test", N_test);
      current_statement__ = 155;
      validate_non_negative_index("log_p_test_conj", "M", M);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += lapse_rate_param_1dim__;
      num_params_r__ += m_0_param_1dim__ * K;
      num_params_r__ += m_0_tau_1dim__;
      num_params_r__ += ((m_0_L_omega_1dim__ * (m_0_L_omega_1dim__ - 1)) / 2);
      num_params_r__ += tau_0_param_1dim__ * K;
      num_params_r__ += L_omega_0_param_1dim__ * ((K * (K - 1)) / 2);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "model_mvg_conj_sufficient_stats_lapse_namespace::log_prob";
(void) function__;  // suppress unused var warning
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      local_scalar_t__ kappa_0;
      kappa_0 = DUMMY_VAR__;
      
      current_statement__ = 1;
      kappa_0 = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        kappa_0 = stan::math::lb_constrain(kappa_0, K, lp__);
      } else {
        current_statement__ = 1;
        kappa_0 = stan::math::lb_constrain(kappa_0, K);
      }
      local_scalar_t__ nu_0;
      nu_0 = DUMMY_VAR__;
      
      current_statement__ = 2;
      nu_0 = in__.scalar();
      current_statement__ = 2;
      if (jacobian__) {
        current_statement__ = 2;
        nu_0 = stan::math::lb_constrain(nu_0, (K + 1), lp__);
      } else {
        current_statement__ = 2;
        nu_0 = stan::math::lb_constrain(nu_0, (K + 1));
      }
      std::vector<local_scalar_t__> lapse_rate_param;
      lapse_rate_param = std::vector<local_scalar_t__>(lapse_rate_param_1dim__, DUMMY_VAR__);
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= lapse_rate_param_1dim__; ++sym1__) {
        current_statement__ = 3;
        assign(lapse_rate_param,
          cons_list(index_uni(sym1__), nil_index_list()), in__.scalar(),
          "assigning variable lapse_rate_param");}
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= lapse_rate_param_1dim__; ++sym1__) {
        current_statement__ = 3;
        if (jacobian__) {
          current_statement__ = 3;
          assign(lapse_rate_param,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(lapse_rate_param[(sym1__ - 1)], 0, 1,
              lp__), "assigning variable lapse_rate_param");
        } else {
          current_statement__ = 3;
          assign(lapse_rate_param,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(lapse_rate_param[(sym1__ - 1)], 0, 1),
            "assigning variable lapse_rate_param");
        }}
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> m_0_param;
      m_0_param = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(m_0_param_1dim__, Eigen::Matrix<local_scalar_t__, -1, 1>(K));
      stan::math::fill(m_0_param, DUMMY_VAR__);
      
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= m_0_param_1dim__; ++sym1__) {
        current_statement__ = 4;
        assign(m_0_param, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(K), "assigning variable m_0_param");}
      Eigen::Matrix<local_scalar_t__, -1, 1> m_0_tau;
      m_0_tau = Eigen::Matrix<local_scalar_t__, -1, 1>(m_0_tau_1dim__);
      stan::math::fill(m_0_tau, DUMMY_VAR__);
      
      current_statement__ = 5;
      m_0_tau = in__.vector(m_0_tau_1dim__);
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= m_0_tau_1dim__; ++sym1__) {
        current_statement__ = 5;
        if (jacobian__) {
          current_statement__ = 5;
          assign(m_0_tau, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(m_0_tau[(sym1__ - 1)], 0, lp__),
            "assigning variable m_0_tau");
        } else {
          current_statement__ = 5;
          assign(m_0_tau, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(m_0_tau[(sym1__ - 1)], 0),
            "assigning variable m_0_tau");
        }}
      Eigen::Matrix<local_scalar_t__, -1, -1> m_0_L_omega;
      m_0_L_omega = Eigen::Matrix<local_scalar_t__, -1, -1>(m_0_L_omega_1dim__, m_0_L_omega_2dim__);
      stan::math::fill(m_0_L_omega, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> m_0_L_omega_in__;
      m_0_L_omega_in__ = Eigen::Matrix<local_scalar_t__, -1, 1>(((m_0_L_omega_1dim__
                                                                   *
                                                                   (m_0_L_omega_1dim__
                                                                    - 1)) /
                                                                  2));
      stan::math::fill(m_0_L_omega_in__, DUMMY_VAR__);
      
      current_statement__ = 6;
      m_0_L_omega_in__ = in__.vector(
                           ((m_0_L_omega_1dim__ * (m_0_L_omega_1dim__ - 1)) /
                             2));
      current_statement__ = 6;
      if (jacobian__) {
        current_statement__ = 6;
        assign(m_0_L_omega, nil_index_list(),
          stan::math::cholesky_corr_constrain(m_0_L_omega_in__,
            m_0_L_omega_1dim__, lp__), "assigning variable m_0_L_omega");
      } else {
        current_statement__ = 6;
        assign(m_0_L_omega, nil_index_list(),
          stan::math::cholesky_corr_constrain(m_0_L_omega_in__,
            m_0_L_omega_1dim__), "assigning variable m_0_L_omega");
      }
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> tau_0_param;
      tau_0_param = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(tau_0_param_1dim__, Eigen::Matrix<local_scalar_t__, -1, 1>(K));
      stan::math::fill(tau_0_param, DUMMY_VAR__);
      
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= tau_0_param_1dim__; ++sym1__) {
        current_statement__ = 7;
        assign(tau_0_param, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(K), "assigning variable tau_0_param");}
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= tau_0_param_1dim__; ++sym1__) {
        current_statement__ = 7;
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          current_statement__ = 7;
          if (jacobian__) {
            current_statement__ = 7;
            assign(tau_0_param,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__), nil_index_list())),
              stan::math::lb_constrain(
                tau_0_param[(sym1__ - 1)][(sym2__ - 1)], 0, lp__),
              "assigning variable tau_0_param");
          } else {
            current_statement__ = 7;
            assign(tau_0_param,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__), nil_index_list())),
              stan::math::lb_constrain(
                tau_0_param[(sym1__ - 1)][(sym2__ - 1)], 0),
              "assigning variable tau_0_param");
          }}}
      std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>> L_omega_0_param;
      L_omega_0_param = std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(L_omega_0_param_1dim__, Eigen::Matrix<local_scalar_t__, -1, -1>(K, K));
      stan::math::fill(L_omega_0_param, DUMMY_VAR__);
      
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> L_omega_0_param_in__;
      L_omega_0_param_in__ = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(L_omega_0_param_1dim__, Eigen::Matrix<local_scalar_t__, -1, 1>(
        ((K * (K - 1)) / 2)));
      stan::math::fill(L_omega_0_param_in__, DUMMY_VAR__);
      
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= L_omega_0_param_1dim__; ++sym1__) {
        current_statement__ = 8;
        assign(L_omega_0_param_in__,
          cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(((K * (K - 1)) / 2)),
          "assigning variable L_omega_0_param_in__");}
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= L_omega_0_param_1dim__; ++sym1__) {
        current_statement__ = 8;
        if (jacobian__) {
          current_statement__ = 8;
          assign(L_omega_0_param,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::cholesky_corr_constrain(
              L_omega_0_param_in__[(sym1__ - 1)], K, lp__),
            "assigning variable L_omega_0_param");
        } else {
          current_statement__ = 8;
          assign(L_omega_0_param,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::cholesky_corr_constrain(
              L_omega_0_param_in__[(sym1__ - 1)], K),
            "assigning variable L_omega_0_param");
        }}
      local_scalar_t__ lapse_rate;
      lapse_rate = DUMMY_VAR__;
      
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> m_0;
      m_0 = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(M, Eigen::Matrix<local_scalar_t__, -1, 1>(K));
      stan::math::fill(m_0, DUMMY_VAR__);
      
      std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>> S_0;
      S_0 = std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(M, Eigen::Matrix<local_scalar_t__, -1, -1>(K, K));
      stan::math::fill(S_0, DUMMY_VAR__);
      
      std::vector<std::vector<local_scalar_t__>> kappa_n;
      kappa_n = std::vector<std::vector<local_scalar_t__>>(M, std::vector<local_scalar_t__>(L, DUMMY_VAR__));
      
      std::vector<std::vector<local_scalar_t__>> nu_n;
      nu_n = std::vector<std::vector<local_scalar_t__>>(M, std::vector<local_scalar_t__>(L, DUMMY_VAR__));
      
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>> m_n;
      m_n = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(M, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(L, Eigen::Matrix<local_scalar_t__, -1, 1>(K)));
      stan::math::fill(m_n, DUMMY_VAR__);
      
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>> S_n;
      S_n = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>>(M, std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(L, Eigen::Matrix<local_scalar_t__, -1, -1>(K, K)));
      stan::math::fill(S_n, DUMMY_VAR__);
      
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>> t_scale;
      t_scale = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>>(M, std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(L, Eigen::Matrix<local_scalar_t__, -1, -1>(K, K)));
      stan::math::fill(t_scale, DUMMY_VAR__);
      
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> p_test_conj;
      p_test_conj = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(N_test, Eigen::Matrix<local_scalar_t__, -1, 1>(M));
      stan::math::fill(p_test_conj, DUMMY_VAR__);
      
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> log_p_test_conj;
      log_p_test_conj = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(N_test, Eigen::Matrix<local_scalar_t__, -1, 1>(M));
      stan::math::fill(log_p_test_conj, DUMMY_VAR__);
      
      current_statement__ = 23;
      if (lapse_rate_known) {
        current_statement__ = 21;
        lapse_rate = lapse_rate_data[(1 - 1)];
      } else {
        current_statement__ = 19;
        lapse_rate = lapse_rate_param[(1 - 1)];
      }
      current_statement__ = 28;
      if (m_0_known) {
        current_statement__ = 26;
        assign(m_0, nil_index_list(), m_0_data, "assigning variable m_0");
      } else {
        current_statement__ = 24;
        assign(m_0, nil_index_list(), m_0_param, "assigning variable m_0");
      }
      current_statement__ = 31;
      if (S_0_known) {
        current_statement__ = 29;
        assign(S_0, nil_index_list(), S_0_data, "assigning variable S_0");
      } 
      current_statement__ = 50;
      for (int cat = 1; cat <= M; ++cat) {
        current_statement__ = 34;
        if (logical_negation(S_0_known)) {
          current_statement__ = 32;
          assign(S_0, cons_list(index_uni(cat), nil_index_list()),
            quad_form_diag(
              multiply_lower_tri_self_transpose(L_omega_0_param[(cat - 1)]),
              tau_0_param[(cat - 1)]), "assigning variable S_0");
        } 
        current_statement__ = 48;
        for (int group = 1; group <= L; ++group) {
          current_statement__ = 45;
          if (logical_gt(
                rvalue(N,
                  cons_list(index_uni(cat),
                    cons_list(index_uni(group), nil_index_list())), "N"), 0)) {
            current_statement__ = 40;
            assign(kappa_n,
              cons_list(index_uni(cat),
                cons_list(index_uni(group), nil_index_list())),
              (kappa_0 +
                rvalue(N,
                  cons_list(index_uni(cat),
                    cons_list(index_uni(group), nil_index_list())), "N")),
              "assigning variable kappa_n");
            current_statement__ = 41;
            assign(nu_n,
              cons_list(index_uni(cat),
                cons_list(index_uni(group), nil_index_list())),
              (nu_0 +
                rvalue(N,
                  cons_list(index_uni(cat),
                    cons_list(index_uni(group), nil_index_list())), "N")),
              "assigning variable nu_n");
            current_statement__ = 42;
            assign(m_n,
              cons_list(index_uni(cat),
                cons_list(index_uni(group), nil_index_list())),
              divide(
                add(multiply(kappa_0, m_0[(cat - 1)]),
                  multiply(
                    rvalue(N,
                      cons_list(index_uni(cat),
                        cons_list(index_uni(group), nil_index_list())), "N"),
                    x_mean[(cat - 1)][(group - 1)])),
                kappa_n[(cat - 1)][(group - 1)]), "assigning variable m_n");
            current_statement__ = 43;
            assign(S_n,
              cons_list(index_uni(cat),
                cons_list(index_uni(group), nil_index_list())),
              subtract(
                add(add(S_0[(cat - 1)], x_ss[(cat - 1)][(group - 1)]),
                  multiply(multiply(kappa_0, m_0[(cat - 1)]),
                    transpose(m_0[(cat - 1)]))),
                multiply(
                  multiply(kappa_n[(cat - 1)][(group - 1)],
                    m_n[(cat - 1)][(group - 1)]),
                  transpose(m_n[(cat - 1)][(group - 1)]))),
              "assigning variable S_n");
          } else {
            current_statement__ = 35;
            assign(kappa_n,
              cons_list(index_uni(cat),
                cons_list(index_uni(group), nil_index_list())), kappa_0,
              "assigning variable kappa_n");
            current_statement__ = 36;
            assign(nu_n,
              cons_list(index_uni(cat),
                cons_list(index_uni(group), nil_index_list())), nu_0,
              "assigning variable nu_n");
            current_statement__ = 37;
            assign(m_n,
              cons_list(index_uni(cat),
                cons_list(index_uni(group), nil_index_list())),
              m_0[(cat - 1)], "assigning variable m_n");
            current_statement__ = 38;
            assign(S_n,
              cons_list(index_uni(cat),
                cons_list(index_uni(group), nil_index_list())),
              S_0[(cat - 1)], "assigning variable S_n");
          }
          current_statement__ = 46;
          assign(t_scale,
            cons_list(index_uni(cat),
              cons_list(index_uni(group), nil_index_list())),
            divide(
              multiply(S_n[(cat - 1)][(group - 1)],
                (kappa_n[(cat - 1)][(group - 1)] + 1)),
              (kappa_n[(cat - 1)][(group - 1)] *
                ((nu_n[(cat - 1)][(group - 1)] - K) + 1))),
            "assigning variable t_scale");}}
      current_statement__ = 58;
      for (int j = 1; j <= N_test; ++j) {
        int group;
        group = std::numeric_limits<int>::min();
        
        current_statement__ = 52;
        group = y_test[(j - 1)];
        current_statement__ = 55;
        for (int cat = 1; cat <= M; ++cat) {
          current_statement__ = 53;
          assign(log_p_test_conj,
            cons_list(index_uni(j),
              cons_list(index_uni(cat), nil_index_list())),
            multi_student_t_lpdf<false>(x_test[(j - 1)],
              ((nu_n[(cat - 1)][(group - 1)] - K) + 1),
              m_n[(cat - 1)][(group - 1)], t_scale[(cat - 1)][(group - 1)]),
            "assigning variable log_p_test_conj");}
        current_statement__ = 56;
        assign(p_test_conj, cons_list(index_uni(j), nil_index_list()),
          stan::math::exp(
            subtract(log_p_test_conj[(j - 1)],
              log_sum_exp(log_p_test_conj[(j - 1)]))),
          "assigning variable p_test_conj");}
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 11;
        current_statement__ = 11;
        check_cov_matrix(function__, "S_0[sym1__]", S_0[(sym1__ - 1)]);}
      current_statement__ = 12;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 12;
        for (int sym2__ = 1; sym2__ <= L; ++sym2__) {
          current_statement__ = 12;
          current_statement__ = 12;
          check_greater_or_equal(function__, "kappa_n[sym1__, sym2__]",
                                 kappa_n[(sym1__ - 1)][(sym2__ - 1)], K);}}
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 13;
        for (int sym2__ = 1; sym2__ <= L; ++sym2__) {
          current_statement__ = 13;
          current_statement__ = 13;
          check_greater_or_equal(function__, "nu_n[sym1__, sym2__]",
                                 nu_n[(sym1__ - 1)][(sym2__ - 1)], K);}}
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 15;
        for (int sym2__ = 1; sym2__ <= L; ++sym2__) {
          current_statement__ = 15;
          current_statement__ = 15;
          check_cov_matrix(function__, "S_n[sym1__, sym2__]",
                           S_n[(sym1__ - 1)][(sym2__ - 1)]);}}
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 16;
        for (int sym2__ = 1; sym2__ <= L; ++sym2__) {
          current_statement__ = 16;
          current_statement__ = 16;
          check_cov_matrix(function__, "t_scale[sym1__, sym2__]",
                           t_scale[(sym1__ - 1)][(sym2__ - 1)]);}}
      current_statement__ = 17;
      for (int sym1__ = 1; sym1__ <= N_test; ++sym1__) {
        current_statement__ = 17;
        current_statement__ = 17;
        check_simplex(function__, "p_test_conj[sym1__]",
                      p_test_conj[(sym1__ - 1)]);}
      {
        current_statement__ = 69;
        validate_non_negative_index("lapsing_probs", "M", M);
        Eigen::Matrix<local_scalar_t__, -1, 1> lapsing_probs;
        lapsing_probs = Eigen::Matrix<local_scalar_t__, -1, 1>(M);
        stan::math::fill(lapsing_probs, DUMMY_VAR__);
        
        current_statement__ = 71;
        assign(lapsing_probs, nil_index_list(),
          rep_vector((lapse_rate / M), M), "assigning variable lapsing_probs");
        current_statement__ = 72;
        lp_accum__.add(normal_lpdf<propto__>(kappa_0, 0, sigma_kappanu));
        current_statement__ = 73;
        lp_accum__.add(normal_lpdf<propto__>(nu_0, 0, sigma_kappanu));
        current_statement__ = 78;
        if (logical_negation(m_0_known)) {
          current_statement__ = 74;
          lp_accum__.add(
            cauchy_lpdf<propto__>(m_0_tau, 0,
              (logical_gt(tau_scale, 0) ?
                 stan::math::promote_scalar<double>(tau_scale) :
                 stan::math::promote_scalar<double>(5))));
          current_statement__ = 75;
          lp_accum__.add(
            lkj_corr_cholesky_lpdf<propto__>(m_0_L_omega,
              (logical_gt(L_omega_scale, 0) ?
                 stan::math::promote_scalar<double>(L_omega_scale) :
                 stan::math::promote_scalar<double>(1))));
          current_statement__ = 76;
          lp_accum__.add(
            multi_normal_cholesky_lpdf<propto__>(m_0_param, rep_vector(0, K),
              diag_pre_multiply(m_0_tau, m_0_L_omega)));
        } 
        current_statement__ = 84;
        if (logical_negation(S_0_known)) {
          current_statement__ = 82;
          for (int cat = 1; cat <= M; ++cat) {
            current_statement__ = 79;
            lp_accum__.add(
              cauchy_lpdf<propto__>(tau_0_param[(cat - 1)], 0,
                (logical_gt(tau_scale, 0) ?
                   stan::math::promote_scalar<double>(tau_scale) :
                   stan::math::promote_scalar<double>(10))));
            current_statement__ = 80;
            lp_accum__.add(
              lkj_corr_cholesky_lpdf<propto__>(L_omega_0_param[(cat - 1)],
                (logical_gt(L_omega_scale, 0) ?
                   stan::math::promote_scalar<double>(L_omega_scale) :
                   stan::math::promote_scalar<double>(1))));}
        } 
        current_statement__ = 87;
        for (int i = 1; i <= N_test; ++i) {
          current_statement__ = 85;
          lp_accum__.add(
            multinomial_lpmf<propto__>(z_test_counts[(i - 1)],
              add(multiply(p_test_conj[(i - 1)], (1 - lapse_rate)),
                lapsing_probs)));}
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "model_mvg_conj_sufficient_stats_lapse_namespace::write_array";
(void) function__;  // suppress unused var warning
    (void) function__;  // suppress unused var warning
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      double kappa_0;
      kappa_0 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      kappa_0 = in__.scalar();
      current_statement__ = 1;
      kappa_0 = stan::math::lb_constrain(kappa_0, K);
      double nu_0;
      nu_0 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      nu_0 = in__.scalar();
      current_statement__ = 2;
      nu_0 = stan::math::lb_constrain(nu_0, (K + 1));
      std::vector<double> lapse_rate_param;
      lapse_rate_param = std::vector<double>(lapse_rate_param_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= lapse_rate_param_1dim__; ++sym1__) {
        current_statement__ = 3;
        assign(lapse_rate_param,
          cons_list(index_uni(sym1__), nil_index_list()), in__.scalar(),
          "assigning variable lapse_rate_param");}
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= lapse_rate_param_1dim__; ++sym1__) {
        current_statement__ = 3;
        assign(lapse_rate_param,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_constrain(lapse_rate_param[(sym1__ - 1)], 0, 1),
          "assigning variable lapse_rate_param");}
      std::vector<Eigen::Matrix<double, -1, 1>> m_0_param;
      m_0_param = std::vector<Eigen::Matrix<double, -1, 1>>(m_0_param_1dim__, Eigen::Matrix<double, -1, 1>(K));
      stan::math::fill(m_0_param, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= m_0_param_1dim__; ++sym1__) {
        current_statement__ = 4;
        assign(m_0_param, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(K), "assigning variable m_0_param");}
      Eigen::Matrix<double, -1, 1> m_0_tau;
      m_0_tau = Eigen::Matrix<double, -1, 1>(m_0_tau_1dim__);
      stan::math::fill(m_0_tau, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      m_0_tau = in__.vector(m_0_tau_1dim__);
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= m_0_tau_1dim__; ++sym1__) {
        current_statement__ = 5;
        assign(m_0_tau, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(m_0_tau[(sym1__ - 1)], 0),
          "assigning variable m_0_tau");}
      Eigen::Matrix<double, -1, -1> m_0_L_omega;
      m_0_L_omega = Eigen::Matrix<double, -1, -1>(m_0_L_omega_1dim__, m_0_L_omega_2dim__);
      stan::math::fill(m_0_L_omega, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<local_scalar_t__, -1, 1> m_0_L_omega_in__;
      m_0_L_omega_in__ = Eigen::Matrix<local_scalar_t__, -1, 1>(((m_0_L_omega_1dim__
                                                                   *
                                                                   (m_0_L_omega_1dim__
                                                                    - 1)) /
                                                                  2));
      stan::math::fill(m_0_L_omega_in__, DUMMY_VAR__);
      
      current_statement__ = 6;
      m_0_L_omega_in__ = in__.vector(
                           ((m_0_L_omega_1dim__ * (m_0_L_omega_1dim__ - 1)) /
                             2));
      current_statement__ = 6;
      assign(m_0_L_omega, nil_index_list(),
        stan::math::cholesky_corr_constrain(m_0_L_omega_in__,
          m_0_L_omega_1dim__), "assigning variable m_0_L_omega");
      std::vector<Eigen::Matrix<double, -1, 1>> tau_0_param;
      tau_0_param = std::vector<Eigen::Matrix<double, -1, 1>>(tau_0_param_1dim__, Eigen::Matrix<double, -1, 1>(K));
      stan::math::fill(tau_0_param, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= tau_0_param_1dim__; ++sym1__) {
        current_statement__ = 7;
        assign(tau_0_param, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(K), "assigning variable tau_0_param");}
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= tau_0_param_1dim__; ++sym1__) {
        current_statement__ = 7;
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          current_statement__ = 7;
          assign(tau_0_param,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            stan::math::lb_constrain(tau_0_param[(sym1__ - 1)][(sym2__ - 1)],
              0), "assigning variable tau_0_param");}}
      std::vector<Eigen::Matrix<double, -1, -1>> L_omega_0_param;
      L_omega_0_param = std::vector<Eigen::Matrix<double, -1, -1>>(L_omega_0_param_1dim__, Eigen::Matrix<double, -1, -1>(K, K));
      stan::math::fill(L_omega_0_param, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> L_omega_0_param_in__;
      L_omega_0_param_in__ = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(L_omega_0_param_1dim__, Eigen::Matrix<local_scalar_t__, -1, 1>(
        ((K * (K - 1)) / 2)));
      stan::math::fill(L_omega_0_param_in__, DUMMY_VAR__);
      
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= L_omega_0_param_1dim__; ++sym1__) {
        current_statement__ = 8;
        assign(L_omega_0_param_in__,
          cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(((K * (K - 1)) / 2)),
          "assigning variable L_omega_0_param_in__");}
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= L_omega_0_param_1dim__; ++sym1__) {
        current_statement__ = 8;
        assign(L_omega_0_param,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::cholesky_corr_constrain(
            L_omega_0_param_in__[(sym1__ - 1)], K),
          "assigning variable L_omega_0_param");}
      double lapse_rate;
      lapse_rate = std::numeric_limits<double>::quiet_NaN();
      
      std::vector<Eigen::Matrix<double, -1, 1>> m_0;
      m_0 = std::vector<Eigen::Matrix<double, -1, 1>>(M, Eigen::Matrix<double, -1, 1>(K));
      stan::math::fill(m_0, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<Eigen::Matrix<double, -1, -1>> S_0;
      S_0 = std::vector<Eigen::Matrix<double, -1, -1>>(M, Eigen::Matrix<double, -1, -1>(K, K));
      stan::math::fill(S_0, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<std::vector<double>> kappa_n;
      kappa_n = std::vector<std::vector<double>>(M, std::vector<double>(L, std::numeric_limits<double>::quiet_NaN()));
      
      std::vector<std::vector<double>> nu_n;
      nu_n = std::vector<std::vector<double>>(M, std::vector<double>(L, std::numeric_limits<double>::quiet_NaN()));
      
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> m_n;
      m_n = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(M, std::vector<Eigen::Matrix<double, -1, 1>>(L, Eigen::Matrix<double, -1, 1>(K)));
      stan::math::fill(m_n, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<std::vector<Eigen::Matrix<double, -1, -1>>> S_n;
      S_n = std::vector<std::vector<Eigen::Matrix<double, -1, -1>>>(M, std::vector<Eigen::Matrix<double, -1, -1>>(L, Eigen::Matrix<double, -1, -1>(K, K)));
      stan::math::fill(S_n, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<std::vector<Eigen::Matrix<double, -1, -1>>> t_scale;
      t_scale = std::vector<std::vector<Eigen::Matrix<double, -1, -1>>>(M, std::vector<Eigen::Matrix<double, -1, -1>>(L, Eigen::Matrix<double, -1, -1>(K, K)));
      stan::math::fill(t_scale, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<Eigen::Matrix<double, -1, 1>> p_test_conj;
      p_test_conj = std::vector<Eigen::Matrix<double, -1, 1>>(N_test, Eigen::Matrix<double, -1, 1>(M));
      stan::math::fill(p_test_conj, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<Eigen::Matrix<double, -1, 1>> log_p_test_conj;
      log_p_test_conj = std::vector<Eigen::Matrix<double, -1, 1>>(N_test, Eigen::Matrix<double, -1, 1>(M));
      stan::math::fill(log_p_test_conj, std::numeric_limits<double>::quiet_NaN());
      
      vars__.emplace_back(kappa_0);
      vars__.emplace_back(nu_0);
      for (int sym1__ = 1; sym1__ <= lapse_rate_param_1dim__; ++sym1__) {
        vars__.emplace_back(lapse_rate_param[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m_0_param_1dim__; ++sym2__) {
          vars__.emplace_back(m_0_param[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= m_0_tau_1dim__; ++sym1__) {
        vars__.emplace_back(m_0_tau[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= m_0_L_omega_2dim__; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= m_0_L_omega_1dim__; ++sym2__) {
          vars__.emplace_back(
            rvalue(m_0_L_omega,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              "m_0_L_omega"));}}
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= tau_0_param_1dim__; ++sym2__) {
          vars__.emplace_back(tau_0_param[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= L_omega_0_param_1dim__; ++sym3__) {
            vars__.emplace_back(
              rvalue(L_omega_0_param,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                "L_omega_0_param"));}}}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 23;
      if (lapse_rate_known) {
        current_statement__ = 21;
        lapse_rate = lapse_rate_data[(1 - 1)];
      } else {
        current_statement__ = 19;
        lapse_rate = lapse_rate_param[(1 - 1)];
      }
      current_statement__ = 28;
      if (m_0_known) {
        current_statement__ = 26;
        assign(m_0, nil_index_list(), m_0_data, "assigning variable m_0");
      } else {
        current_statement__ = 24;
        assign(m_0, nil_index_list(), m_0_param, "assigning variable m_0");
      }
      current_statement__ = 31;
      if (S_0_known) {
        current_statement__ = 29;
        assign(S_0, nil_index_list(), S_0_data, "assigning variable S_0");
      } 
      current_statement__ = 50;
      for (int cat = 1; cat <= M; ++cat) {
        current_statement__ = 34;
        if (logical_negation(S_0_known)) {
          current_statement__ = 32;
          assign(S_0, cons_list(index_uni(cat), nil_index_list()),
            quad_form_diag(
              multiply_lower_tri_self_transpose(L_omega_0_param[(cat - 1)]),
              tau_0_param[(cat - 1)]), "assigning variable S_0");
        } 
        current_statement__ = 48;
        for (int group = 1; group <= L; ++group) {
          current_statement__ = 45;
          if (logical_gt(
                rvalue(N,
                  cons_list(index_uni(cat),
                    cons_list(index_uni(group), nil_index_list())), "N"), 0)) {
            current_statement__ = 40;
            assign(kappa_n,
              cons_list(index_uni(cat),
                cons_list(index_uni(group), nil_index_list())),
              (kappa_0 +
                rvalue(N,
                  cons_list(index_uni(cat),
                    cons_list(index_uni(group), nil_index_list())), "N")),
              "assigning variable kappa_n");
            current_statement__ = 41;
            assign(nu_n,
              cons_list(index_uni(cat),
                cons_list(index_uni(group), nil_index_list())),
              (nu_0 +
                rvalue(N,
                  cons_list(index_uni(cat),
                    cons_list(index_uni(group), nil_index_list())), "N")),
              "assigning variable nu_n");
            current_statement__ = 42;
            assign(m_n,
              cons_list(index_uni(cat),
                cons_list(index_uni(group), nil_index_list())),
              divide(
                add(multiply(kappa_0, m_0[(cat - 1)]),
                  multiply(
                    rvalue(N,
                      cons_list(index_uni(cat),
                        cons_list(index_uni(group), nil_index_list())), "N"),
                    x_mean[(cat - 1)][(group - 1)])),
                kappa_n[(cat - 1)][(group - 1)]), "assigning variable m_n");
            current_statement__ = 43;
            assign(S_n,
              cons_list(index_uni(cat),
                cons_list(index_uni(group), nil_index_list())),
              subtract(
                add(add(S_0[(cat - 1)], x_ss[(cat - 1)][(group - 1)]),
                  multiply(multiply(kappa_0, m_0[(cat - 1)]),
                    transpose(m_0[(cat - 1)]))),
                multiply(
                  multiply(kappa_n[(cat - 1)][(group - 1)],
                    m_n[(cat - 1)][(group - 1)]),
                  transpose(m_n[(cat - 1)][(group - 1)]))),
              "assigning variable S_n");
          } else {
            current_statement__ = 35;
            assign(kappa_n,
              cons_list(index_uni(cat),
                cons_list(index_uni(group), nil_index_list())), kappa_0,
              "assigning variable kappa_n");
            current_statement__ = 36;
            assign(nu_n,
              cons_list(index_uni(cat),
                cons_list(index_uni(group), nil_index_list())), nu_0,
              "assigning variable nu_n");
            current_statement__ = 37;
            assign(m_n,
              cons_list(index_uni(cat),
                cons_list(index_uni(group), nil_index_list())),
              m_0[(cat - 1)], "assigning variable m_n");
            current_statement__ = 38;
            assign(S_n,
              cons_list(index_uni(cat),
                cons_list(index_uni(group), nil_index_list())),
              S_0[(cat - 1)], "assigning variable S_n");
          }
          current_statement__ = 46;
          assign(t_scale,
            cons_list(index_uni(cat),
              cons_list(index_uni(group), nil_index_list())),
            divide(
              multiply(S_n[(cat - 1)][(group - 1)],
                (kappa_n[(cat - 1)][(group - 1)] + 1)),
              (kappa_n[(cat - 1)][(group - 1)] *
                ((nu_n[(cat - 1)][(group - 1)] - K) + 1))),
            "assigning variable t_scale");}}
      current_statement__ = 58;
      for (int j = 1; j <= N_test; ++j) {
        int group;
        group = std::numeric_limits<int>::min();
        
        current_statement__ = 52;
        group = y_test[(j - 1)];
        current_statement__ = 55;
        for (int cat = 1; cat <= M; ++cat) {
          current_statement__ = 53;
          assign(log_p_test_conj,
            cons_list(index_uni(j),
              cons_list(index_uni(cat), nil_index_list())),
            multi_student_t_lpdf<false>(x_test[(j - 1)],
              ((nu_n[(cat - 1)][(group - 1)] - K) + 1),
              m_n[(cat - 1)][(group - 1)], t_scale[(cat - 1)][(group - 1)]),
            "assigning variable log_p_test_conj");}
        current_statement__ = 56;
        assign(p_test_conj, cons_list(index_uni(j), nil_index_list()),
          stan::math::exp(
            subtract(log_p_test_conj[(j - 1)],
              log_sum_exp(log_p_test_conj[(j - 1)]))),
          "assigning variable p_test_conj");}
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 11;
        current_statement__ = 11;
        check_cov_matrix(function__, "S_0[sym1__]", S_0[(sym1__ - 1)]);}
      current_statement__ = 12;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 12;
        for (int sym2__ = 1; sym2__ <= L; ++sym2__) {
          current_statement__ = 12;
          current_statement__ = 12;
          check_greater_or_equal(function__, "kappa_n[sym1__, sym2__]",
                                 kappa_n[(sym1__ - 1)][(sym2__ - 1)], K);}}
      current_statement__ = 13;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 13;
        for (int sym2__ = 1; sym2__ <= L; ++sym2__) {
          current_statement__ = 13;
          current_statement__ = 13;
          check_greater_or_equal(function__, "nu_n[sym1__, sym2__]",
                                 nu_n[(sym1__ - 1)][(sym2__ - 1)], K);}}
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 15;
        for (int sym2__ = 1; sym2__ <= L; ++sym2__) {
          current_statement__ = 15;
          current_statement__ = 15;
          check_cov_matrix(function__, "S_n[sym1__, sym2__]",
                           S_n[(sym1__ - 1)][(sym2__ - 1)]);}}
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        current_statement__ = 16;
        for (int sym2__ = 1; sym2__ <= L; ++sym2__) {
          current_statement__ = 16;
          current_statement__ = 16;
          check_cov_matrix(function__, "t_scale[sym1__, sym2__]",
                           t_scale[(sym1__ - 1)][(sym2__ - 1)]);}}
      current_statement__ = 17;
      for (int sym1__ = 1; sym1__ <= N_test; ++sym1__) {
        current_statement__ = 17;
        current_statement__ = 17;
        check_simplex(function__, "p_test_conj[sym1__]",
                      p_test_conj[(sym1__ - 1)]);}
      if (emit_transformed_parameters__) {
        vars__.emplace_back(lapse_rate);
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            vars__.emplace_back(m_0[(sym2__ - 1)][(sym1__ - 1)]);}}
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              vars__.emplace_back(
                rvalue(S_0,
                  cons_list(index_uni(sym3__),
                    cons_list(index_uni(sym2__),
                      cons_list(index_uni(sym1__), nil_index_list()))),
                  "S_0"));}}}
        for (int sym1__ = 1; sym1__ <= L; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            vars__.emplace_back(kappa_n[(sym2__ - 1)][(sym1__ - 1)]);}}
        for (int sym1__ = 1; sym1__ <= L; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            vars__.emplace_back(nu_n[(sym2__ - 1)][(sym1__ - 1)]);}}
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= L; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
              vars__.emplace_back(
                m_n[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}}
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= L; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= M; ++sym4__) {
                vars__.emplace_back(
                  rvalue(S_n,
                    cons_list(index_uni(sym4__),
                      cons_list(index_uni(sym3__),
                        cons_list(index_uni(sym2__),
                          cons_list(index_uni(sym1__), nil_index_list())))),
                    "S_n"));}}}}
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= L; ++sym3__) {
              for (int sym4__ = 1; sym4__ <= M; ++sym4__) {
                vars__.emplace_back(
                  rvalue(t_scale,
                    cons_list(index_uni(sym4__),
                      cons_list(index_uni(sym3__),
                        cons_list(index_uni(sym2__),
                          cons_list(index_uni(sym1__), nil_index_list())))),
                    "t_scale"));}}}}
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N_test; ++sym2__) {
            vars__.emplace_back(p_test_conj[(sym2__ - 1)][(sym1__ - 1)]);}}
        for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= N_test; ++sym2__) {
            vars__.emplace_back(log_p_test_conj[(sym2__ - 1)][(sym1__ - 1)]);
          }}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      current_statement__ = 68;
      if (logical_negation(m_0_known)) {
        current_statement__ = 59;
        validate_non_negative_index("m_0_cor", "K", K);
        current_statement__ = 60;
        validate_non_negative_index("m_0_cor", "K", K);
        Eigen::Matrix<double, -1, -1> m_0_cor;
        m_0_cor = Eigen::Matrix<double, -1, -1>(K, K);
        stan::math::fill(m_0_cor, std::numeric_limits<double>::quiet_NaN());
        
        current_statement__ = 62;
        validate_non_negative_index("m_0_cov", "K", K);
        current_statement__ = 63;
        validate_non_negative_index("m_0_cov", "K", K);
        Eigen::Matrix<double, -1, -1> m_0_cov;
        m_0_cov = Eigen::Matrix<double, -1, -1>(K, K);
        stan::math::fill(m_0_cov, std::numeric_limits<double>::quiet_NaN());
        
        current_statement__ = 65;
        assign(m_0_cor, nil_index_list(),
          multiply_lower_tri_self_transpose(m_0_L_omega),
          "assigning variable m_0_cor");
        current_statement__ = 66;
        assign(m_0_cov, nil_index_list(), quad_form_diag(m_0_cor, m_0_tau),
          "assigning variable m_0_cov");
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double kappa_0;
      kappa_0 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      kappa_0 = context__.vals_r("kappa_0")[(1 - 1)];
      double kappa_0_free__;
      kappa_0_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      kappa_0_free__ = stan::math::lb_free(kappa_0, K);
      double nu_0;
      nu_0 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      nu_0 = context__.vals_r("nu_0")[(1 - 1)];
      double nu_0_free__;
      nu_0_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      nu_0_free__ = stan::math::lb_free(nu_0, (K + 1));
      std::vector<double> lapse_rate_param;
      lapse_rate_param = std::vector<double>(lapse_rate_param_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      assign(lapse_rate_param, nil_index_list(),
        context__.vals_r("lapse_rate_param"),
        "assigning variable lapse_rate_param");
      std::vector<double> lapse_rate_param_free__;
      lapse_rate_param_free__ = std::vector<double>(lapse_rate_param_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= lapse_rate_param_1dim__; ++sym1__) {
        current_statement__ = 3;
        assign(lapse_rate_param_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_free(lapse_rate_param[(sym1__ - 1)], 0, 1),
          "assigning variable lapse_rate_param_free__");}
      std::vector<Eigen::Matrix<double, -1, 1>> m_0_param;
      m_0_param = std::vector<Eigen::Matrix<double, -1, 1>>(m_0_param_1dim__, Eigen::Matrix<double, -1, 1>(K));
      stan::math::fill(m_0_param, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> m_0_param_flat__;
        current_statement__ = 4;
        assign(m_0_param_flat__, nil_index_list(),
          context__.vals_r("m_0_param"),
          "assigning variable m_0_param_flat__");
        current_statement__ = 4;
        pos__ = 1;
        current_statement__ = 4;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          current_statement__ = 4;
          for (int sym2__ = 1; sym2__ <= m_0_param_1dim__; ++sym2__) {
            current_statement__ = 4;
            assign(m_0_param,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              m_0_param_flat__[(pos__ - 1)], "assigning variable m_0_param");
            current_statement__ = 4;
            pos__ = (pos__ + 1);}}
      }
      Eigen::Matrix<double, -1, 1> m_0_tau;
      m_0_tau = Eigen::Matrix<double, -1, 1>(m_0_tau_1dim__);
      stan::math::fill(m_0_tau, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> m_0_tau_flat__;
        current_statement__ = 5;
        assign(m_0_tau_flat__, nil_index_list(), context__.vals_r("m_0_tau"),
          "assigning variable m_0_tau_flat__");
        current_statement__ = 5;
        pos__ = 1;
        current_statement__ = 5;
        for (int sym1__ = 1; sym1__ <= m_0_tau_1dim__; ++sym1__) {
          current_statement__ = 5;
          assign(m_0_tau, cons_list(index_uni(sym1__), nil_index_list()),
            m_0_tau_flat__[(pos__ - 1)], "assigning variable m_0_tau");
          current_statement__ = 5;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> m_0_tau_free__;
      m_0_tau_free__ = Eigen::Matrix<double, -1, 1>(m_0_tau_1dim__);
      stan::math::fill(m_0_tau_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= m_0_tau_1dim__; ++sym1__) {
        current_statement__ = 5;
        assign(m_0_tau_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(m_0_tau[(sym1__ - 1)], 0),
          "assigning variable m_0_tau_free__");}
      Eigen::Matrix<double, -1, -1> m_0_L_omega;
      m_0_L_omega = Eigen::Matrix<double, -1, -1>(m_0_L_omega_1dim__, m_0_L_omega_2dim__);
      stan::math::fill(m_0_L_omega, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> m_0_L_omega_flat__;
        current_statement__ = 6;
        assign(m_0_L_omega_flat__, nil_index_list(),
          context__.vals_r("m_0_L_omega"),
          "assigning variable m_0_L_omega_flat__");
        current_statement__ = 6;
        pos__ = 1;
        current_statement__ = 6;
        for (int sym1__ = 1; sym1__ <= m_0_L_omega_2dim__; ++sym1__) {
          current_statement__ = 6;
          for (int sym2__ = 1; sym2__ <= m_0_L_omega_1dim__; ++sym2__) {
            current_statement__ = 6;
            assign(m_0_L_omega,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              m_0_L_omega_flat__[(pos__ - 1)],
              "assigning variable m_0_L_omega");
            current_statement__ = 6;
            pos__ = (pos__ + 1);}}
      }
      Eigen::Matrix<double, -1, 1> m_0_L_omega_free__;
      m_0_L_omega_free__ = Eigen::Matrix<double, -1, 1>(((m_0_L_omega_1dim__
                                                           *
                                                           (m_0_L_omega_1dim__
                                                             - 1)) / 2));
      stan::math::fill(m_0_L_omega_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 6;
      assign(m_0_L_omega_free__, nil_index_list(),
        stan::math::cholesky_corr_free(m_0_L_omega),
        "assigning variable m_0_L_omega_free__");
      std::vector<Eigen::Matrix<double, -1, 1>> tau_0_param;
      tau_0_param = std::vector<Eigen::Matrix<double, -1, 1>>(tau_0_param_1dim__, Eigen::Matrix<double, -1, 1>(K));
      stan::math::fill(tau_0_param, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> tau_0_param_flat__;
        current_statement__ = 7;
        assign(tau_0_param_flat__, nil_index_list(),
          context__.vals_r("tau_0_param"),
          "assigning variable tau_0_param_flat__");
        current_statement__ = 7;
        pos__ = 1;
        current_statement__ = 7;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          current_statement__ = 7;
          for (int sym2__ = 1; sym2__ <= tau_0_param_1dim__; ++sym2__) {
            current_statement__ = 7;
            assign(tau_0_param,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              tau_0_param_flat__[(pos__ - 1)],
              "assigning variable tau_0_param");
            current_statement__ = 7;
            pos__ = (pos__ + 1);}}
      }
      std::vector<Eigen::Matrix<double, -1, 1>> tau_0_param_free__;
      tau_0_param_free__ = std::vector<Eigen::Matrix<double, -1, 1>>(tau_0_param_1dim__, Eigen::Matrix<double, -1, 1>(K));
      stan::math::fill(tau_0_param_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= tau_0_param_1dim__; ++sym1__) {
        current_statement__ = 7;
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          current_statement__ = 7;
          assign(tau_0_param_free__,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            stan::math::lb_free(tau_0_param[(sym1__ - 1)][(sym2__ - 1)], 0),
            "assigning variable tau_0_param_free__");}}
      std::vector<Eigen::Matrix<double, -1, -1>> L_omega_0_param;
      L_omega_0_param = std::vector<Eigen::Matrix<double, -1, -1>>(L_omega_0_param_1dim__, Eigen::Matrix<double, -1, -1>(K, K));
      stan::math::fill(L_omega_0_param, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> L_omega_0_param_flat__;
        current_statement__ = 8;
        assign(L_omega_0_param_flat__, nil_index_list(),
          context__.vals_r("L_omega_0_param"),
          "assigning variable L_omega_0_param_flat__");
        current_statement__ = 8;
        pos__ = 1;
        current_statement__ = 8;
        for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
          current_statement__ = 8;
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            current_statement__ = 8;
            for (int sym3__ = 1; sym3__ <= L_omega_0_param_1dim__; ++sym3__) {
              current_statement__ = 8;
              assign(L_omega_0_param,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                L_omega_0_param_flat__[(pos__ - 1)],
                "assigning variable L_omega_0_param");
              current_statement__ = 8;
              pos__ = (pos__ + 1);}}}
      }
      std::vector<Eigen::Matrix<double, -1, 1>> L_omega_0_param_free__;
      L_omega_0_param_free__ = std::vector<Eigen::Matrix<double, -1, 1>>(L_omega_0_param_1dim__, Eigen::Matrix<double, -1, 1>(
        ((K * (K - 1)) / 2)));
      stan::math::fill(L_omega_0_param_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= L_omega_0_param_1dim__; ++sym1__) {
        current_statement__ = 8;
        assign(L_omega_0_param_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::cholesky_corr_free(L_omega_0_param[(sym1__ - 1)]),
          "assigning variable L_omega_0_param_free__");}
      vars__.emplace_back(kappa_0_free__);
      vars__.emplace_back(nu_0_free__);
      for (int sym1__ = 1; sym1__ <= lapse_rate_param_1dim__; ++sym1__) {
        vars__.emplace_back(lapse_rate_param_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= m_0_param_1dim__; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          vars__.emplace_back(m_0_param[(sym1__ - 1)][(sym2__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= m_0_tau_1dim__; ++sym1__) {
        vars__.emplace_back(m_0_tau_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1;
           sym1__ <= ((m_0_L_omega_1dim__ * (m_0_L_omega_1dim__ - 1)) / 2);
           ++sym1__) { vars__.emplace_back(m_0_L_omega_free__[(sym1__ - 1)]);
      }
      for (int sym1__ = 1; sym1__ <= tau_0_param_1dim__; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          vars__.emplace_back(
            tau_0_param_free__[(sym1__ - 1)][(sym2__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= L_omega_0_param_1dim__; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= ((K * (K - 1)) / 2); ++sym2__) {
          vars__.emplace_back(
            L_omega_0_param_free__[(sym1__ - 1)][(sym2__ - 1)]);}}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("kappa_0");
    names__.emplace_back("nu_0");
    names__.emplace_back("lapse_rate_param");
    names__.emplace_back("m_0_param");
    names__.emplace_back("m_0_tau");
    names__.emplace_back("m_0_L_omega");
    names__.emplace_back("tau_0_param");
    names__.emplace_back("L_omega_0_param");
    names__.emplace_back("lapse_rate");
    names__.emplace_back("m_0");
    names__.emplace_back("S_0");
    names__.emplace_back("kappa_n");
    names__.emplace_back("nu_n");
    names__.emplace_back("m_n");
    names__.emplace_back("S_n");
    names__.emplace_back("t_scale");
    names__.emplace_back("p_test_conj");
    names__.emplace_back("log_p_test_conj");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(lapse_rate_param_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(m_0_param_1dim__)
                                             , static_cast<size_t>(K)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(m_0_tau_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(m_0_L_omega_1dim__)
                                             ,
                                             static_cast<size_t>(m_0_L_omega_2dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(tau_0_param_1dim__)
                                             , static_cast<size_t>(K)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(L_omega_0_param_1dim__)
                                             , static_cast<size_t>(K),
                                             static_cast<size_t>(K)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(M),
                                             static_cast<size_t>(K)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(M),
                                             static_cast<size_t>(K),
                                             static_cast<size_t>(K)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(M),
                                             static_cast<size_t>(L)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(M),
                                             static_cast<size_t>(L)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(M),
                                             static_cast<size_t>(L),
                                             static_cast<size_t>(K)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(M),
                                             static_cast<size_t>(L),
                                             static_cast<size_t>(K),
                                             static_cast<size_t>(K)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(M),
                                             static_cast<size_t>(L),
                                             static_cast<size_t>(K),
                                             static_cast<size_t>(K)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(N_test),
                                             static_cast<size_t>(M)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(N_test),
                                             static_cast<size_t>(M)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "kappa_0");
    param_names__.emplace_back(std::string() + "nu_0");
    for (int sym1__ = 1; sym1__ <= lapse_rate_param_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "lapse_rate_param" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= m_0_param_1dim__; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "m_0_param" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= m_0_tau_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "m_0_tau" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= m_0_L_omega_2dim__; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= m_0_L_omega_1dim__; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "m_0_L_omega" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= tau_0_param_1dim__; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "tau_0_param" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= L_omega_0_param_1dim__; ++sym3__) {
              {
                param_names__.emplace_back(std::string() + "L_omega_0_param" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "lapse_rate");
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "m_0" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "S_0" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= L; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "kappa_n" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= L; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "nu_n" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= L; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "m_n" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= L; ++sym3__) {
                {
                  for (int sym4__ = 1; sym4__ <= M; ++sym4__) {
                    {
                      param_names__.emplace_back(std::string() + "S_n" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                    }}
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= L; ++sym3__) {
                {
                  for (int sym4__ = 1; sym4__ <= M; ++sym4__) {
                    {
                      param_names__.emplace_back(std::string() + "t_scale" + '.' + std::to_string(sym4__) + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                    }}
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= N_test; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p_test_conj" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= N_test; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "log_p_test_conj" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "kappa_0");
    param_names__.emplace_back(std::string() + "nu_0");
    for (int sym1__ = 1; sym1__ <= lapse_rate_param_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "lapse_rate_param" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= m_0_param_1dim__; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "m_0_param" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= m_0_tau_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "m_0_tau" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1;
         sym1__ <= ((m_0_L_omega_1dim__ * (m_0_L_omega_1dim__ - 1)) / 2);
         ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "m_0_L_omega" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= tau_0_param_1dim__; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "tau_0_param" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= ((K * (K - 1)) / 2); ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= L_omega_0_param_1dim__; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "L_omega_0_param" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "lapse_rate");
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "m_0" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= (K + ((K * (K - 1)) / 2)); ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "S_0" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= L; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "kappa_n" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= L; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= M; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "nu_n" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= L; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "m_n" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= (K + ((K * (K - 1)) / 2)); ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= L; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "S_n" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= (K + ((K * (K - 1)) / 2)); ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= L; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= M; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "t_scale" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= (M - 1); ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= N_test; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "p_test_conj" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= M; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= N_test; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "log_p_test_conj" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"kappa_0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"nu_0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"lapse_rate_param\",\"type\":{\"name\":\"array\",\"length\":" << lapse_rate_param_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"m_0_param\",\"type\":{\"name\":\"array\",\"length\":" << m_0_param_1dim__ << ",\"element_type\":{\"name\":\"vector\",\"length\":" << K << "}},\"block\":\"parameters\"},{\"name\":\"m_0_tau\",\"type\":{\"name\":\"vector\",\"length\":" << m_0_tau_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"m_0_L_omega\",\"type\":{\"name\":\"matrix\",\"rows\":" << m_0_L_omega_1dim__ << ",\"cols\":" << m_0_L_omega_2dim__ << "},\"block\":\"parameters\"},{\"name\":\"tau_0_param\",\"type\":{\"name\":\"array\",\"length\":" << tau_0_param_1dim__ << ",\"element_type\":{\"name\":\"vector\",\"length\":" << K << "}},\"block\":\"parameters\"},{\"name\":\"L_omega_0_param\",\"type\":{\"name\":\"array\",\"length\":" << L_omega_0_param_1dim__ << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << K << ",\"cols\":" << K << "}},\"block\":\"parameters\"},{\"name\":\"lapse_rate\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"m_0\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"vector\",\"length\":" << K << "}},\"block\":\"transformed_parameters\"},{\"name\":\"S_0\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << K << ",\"cols\":" << K << "}},\"block\":\"transformed_parameters\"},{\"name\":\"kappa_n\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << L << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"nu_n\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << L << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"m_n\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << L << ",\"element_type\":{\"name\":\"vector\",\"length\":" << K << "}}},\"block\":\"transformed_parameters\"},{\"name\":\"S_n\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << L << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << K << ",\"cols\":" << K << "}}},\"block\":\"transformed_parameters\"},{\"name\":\"t_scale\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << L << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << K << ",\"cols\":" << K << "}}},\"block\":\"transformed_parameters\"},{\"name\":\"p_test_conj\",\"type\":{\"name\":\"array\",\"length\":" << N_test << ",\"element_type\":{\"name\":\"vector\",\"length\":" << M << "}},\"block\":\"transformed_parameters\"},{\"name\":\"log_p_test_conj\",\"type\":{\"name\":\"array\",\"length\":" << N_test << ",\"element_type\":{\"name\":\"vector\",\"length\":" << M << "}},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"kappa_0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"nu_0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"lapse_rate_param\",\"type\":{\"name\":\"array\",\"length\":" << lapse_rate_param_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"m_0_param\",\"type\":{\"name\":\"array\",\"length\":" << m_0_param_1dim__ << ",\"element_type\":{\"name\":\"vector\",\"length\":" << K << "}},\"block\":\"parameters\"},{\"name\":\"m_0_tau\",\"type\":{\"name\":\"vector\",\"length\":" << m_0_tau_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"m_0_L_omega\",\"type\":{\"name\":\"vector\",\"length\":" << ((m_0_L_omega_1dim__ * (m_0_L_omega_1dim__ - 1)) / 2) << "},\"block\":\"parameters\"},{\"name\":\"tau_0_param\",\"type\":{\"name\":\"array\",\"length\":" << tau_0_param_1dim__ << ",\"element_type\":{\"name\":\"vector\",\"length\":" << K << "}},\"block\":\"parameters\"},{\"name\":\"L_omega_0_param\",\"type\":{\"name\":\"array\",\"length\":" << L_omega_0_param_1dim__ << ",\"element_type\":{\"name\":\"vector\",\"length\":" << ((K * (K - 1)) / 2) << "}},\"block\":\"parameters\"},{\"name\":\"lapse_rate\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"m_0\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"vector\",\"length\":" << K << "}},\"block\":\"transformed_parameters\"},{\"name\":\"S_0\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"vector\",\"length\":" << (K + ((K * (K - 1)) / 2)) << "}},\"block\":\"transformed_parameters\"},{\"name\":\"kappa_n\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << L << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"nu_n\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << L << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"m_n\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << L << ",\"element_type\":{\"name\":\"vector\",\"length\":" << K << "}}},\"block\":\"transformed_parameters\"},{\"name\":\"S_n\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << L << ",\"element_type\":{\"name\":\"vector\",\"length\":" << (K + ((K * (K - 1)) / 2)) << "}}},\"block\":\"transformed_parameters\"},{\"name\":\"t_scale\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << L << ",\"element_type\":{\"name\":\"vector\",\"length\":" << (K + ((K * (K - 1)) / 2)) << "}}},\"block\":\"transformed_parameters\"},{\"name\":\"p_test_conj\",\"type\":{\"name\":\"array\",\"length\":" << N_test << ",\"element_type\":{\"name\":\"vector\",\"length\":" << (M - 1) << "}},\"block\":\"transformed_parameters\"},{\"name\":\"log_p_test_conj\",\"type\":{\"name\":\"array\",\"length\":" << N_test << ",\"element_type\":{\"name\":\"vector\",\"length\":" << M << "}},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }
    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }
    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  
    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        
};
}
using stan_model = model_mvg_conj_sufficient_stats_lapse_namespace::model_mvg_conj_sufficient_stats_lapse;
#ifndef USING_R
// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return model_mvg_conj_sufficient_stats_lapse_namespace::profiles__;
}
#endif
#endif
